import{e as p,r as w,o as s,c as a,a as e,F as b,f,b as c,w as m,T as x,n as g,u as d,t as _,d as o}from"./DICxFz2T.js";import{_ as v}from"./xcXlLDgu.js";const y={class:"flex flex-col h-screen"},k={class:"box"},I={class:"flex flex-row justify-between items-center"},A={class:"menu p-4"},P={class:"flex flex-row"},q=["onClick"],S={class:"relative flex-grow overflow-hidden"},C={key:0,class:"p-4"},N={class:"px-2"},T={key:1,class:"p-4"},$=p({__name:"index",setup(B){const l=[{title:"Home",isSelected:!0},{title:"Playground",isSelected:!1}],n=w({title:"Home",isSelected:!0}),u=i=>{n.value.title=i,n.value.isSelected=!0;for(let t=0;t<l.length;t++)l[t].title!=i?l[t].isSelected=!0:l[t].isSelected=!1};return(i,t)=>(s(),a("div",y,[e("div",k,[e("div",I,[t[0]||(t[0]=e("div",{class:"logo p-4"},[e("p",{class:"text-4xl header-text-bold text-gray-800"},"useNetFlux"),e("p",null,"A powerful network composable & light-weight API playground")],-1)),e("div",A,[e("ul",P,[(s(),a(b,null,f(l,(r,h)=>e("div",null,[(s(),a("div",{class:g(`box button p-4 m-1 ${r.title===d(n).title?"text-teal-400 bg-slate-700":""}`),key:h,onClick:F=>u(r.title)},[e("span",null,_(r.title),1)],10,q))])),64))])])])]),e("div",S,[c(x,{name:"slide",mode:"out-in"},{default:m(()=>[(s(),a("div",{key:d(n).title,class:"box absolute inset-0 overflow-y-scroll"},[d(n).title==="Playground"?(s(),a("div",C,[e("p",N,[c(v)])])):(s(),a("div",T,t[1]||(t[1]=[e("p",{class:"header-text-bold text-2xl p-2"}," Inception ",-1),e("p",{class:"px-2 py-2"},[o(" While working on one a project; I came accross a problem where we had tabs to change the UI; and whenever you'd click on a tab, it would make a new network request to fetch and show new data of that respective tab. Now, if you do it slow enough, it would switch the tab and show a preloader while it fetched the data from the API. "),e("br"),e("br"),o(" But the problem arose if you click tabs quickly, and switched between them fast-enough. This lead to each click triggering an API call; and when the user finally stopped switching between the tabs - it lead to completion of each request one by one - which in turn lead to the data in the UI getting updated in sequence as each API request was resolving a successful response. "),e("br"),e("br"),o(" This was obviously bad user experience, but more than that - it was bad handling of APIs itself. I wanted an architecture which would allow me to abort/cancel the previous on going API request and instead make a new, updated API request. "),e("br"),e("br"),o(" I started exploring what solutions I have available and, sure I could implement a simple solution to this to handle my APIs properly I realized that there is no API controller or package that would provide me with any control over my requests. Hence, "),e("u",null,"useNetFlux"),o(" was born. "),e("br"),e("br"),o(" A detailed documentation and & list of features will be published soon, I am working on it. ")],-1)])))]))]),_:1})])]))}});export{$ as default};
