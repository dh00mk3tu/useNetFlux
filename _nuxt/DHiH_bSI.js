import{e as b,r as w,o,c as a,a as e,F as f,f as p,b as c,w as m,T as g,n as x,u as d,t as y,d as s}from"./Cs7W1Q7g.js";import{_ as v}from"./SNO_XaJp.js";const _={class:"flex flex-col h-screen"},k={class:"box"},I={class:"flex flex-row justify-between items-center"},q={class:"menu p-4"},A={class:"flex flex-row"},P=["onClick"],S={class:"relative flex-grow overflow-hidden"},T={key:0,class:"p-4"},N={class:"px-2"},C={key:1,class:"p-4"},V=b({__name:"index",setup(j){const l=[{title:"Home",isSelected:!0},{title:"Playground",isSelected:!1}],n=w({title:"Home",isSelected:!0}),u=i=>{n.value.title=i,n.value.isSelected=!0;for(let t=0;t<l.length;t++)l[t].title!=i?l[t].isSelected=!0:l[t].isSelected=!1};return(i,t)=>(o(),a("div",_,[e("div",k,[e("div",I,[t[0]||(t[0]=e("div",{class:"logo p-4"},[e("p",{class:"text-4xl header-text-bold text-gray-800"},"useNetFlux"),e("p",null,"A powerful network composable & light-weight API playground")],-1)),e("div",q,[e("ul",A,[(o(),a(f,null,p(l,(r,h)=>e("div",null,[(o(),a("div",{class:x(`box button p-4 m-1 ${r.title===d(n).title?"text-teal-400 bg-slate-700":""}`),key:h,onClick:B=>u(r.title)},[e("span",null,y(r.title),1)],10,P))])),64))])])])]),e("div",S,[c(g,{name:"slide",mode:"out-in"},{default:m(()=>[(o(),a("div",{key:d(n).title,class:"box absolute inset-0 overflow-y-scroll"},[d(n).title==="Playground"?(o(),a("div",T,[e("p",N,[c(v)])])):(o(),a("div",C,t[1]||(t[1]=[e("p",{class:"header-text-bold text-2xl p-2"},"Inception",-1),e("p",{class:"px-2 py-2"},[s(" While working on one a project; I came accross a problem where we had tabs to change the UI; and whenever you'd click on a tab, it would make a new network request to fetch and show new data of that respective tab. Now, if you do it slow enough, it would switch the tab and show a preloader while it fetched the data from the API. "),e("br"),e("br"),s(" But the problem arose if you click tabs quickly, and switched between them fast-enough. This lead to each click triggering an API call; and when the user finally stopped switching between the tabs - it lead to completion of each request one by one - which in turn lead to the data in the UI getting updated in sequence as each API request was resolving a successful response, one-by-one and updating the local response state as well. "),e("br"),e("br"),s(" This was obviously bad user experience, but more than that - it was bad handling of APIs itself. Now, one may suggest that I could simply debouce the API requests using setTimeout or use lodash debounce function to handle this, but I wanted more control over my API requests. I wanted an architecture in my API request process and control over the requests which would allow me to abort/cancel the previous on going APIrequest and instead make a new, updated API request. "),e("br"),e("br"),s(' There are libraries like TanStack Query, React Query, SWR etc. which provide control over the requests but I dont want to a library that requires me to "learn" it. All of these libraries come with a lot of features out of the box and I am not looking for that. I just want a simple solution to handle my API requests and have control over them. '),e("br"),e("br"),s(" I started exploring the solutions and what my options are and there was none that would suffice my needs. Hence, "),e("u",null,"useNetFlux"),s(" was born. "),e("br"),e("br"),s(" A detailed list of features and about the project can be found "),e("a",{href:"https://dh00mk3tu.github.io/blogs/posts/use-net-stack/"},"here")],-1)])))]))]),_:1})])]))}});export{V as default};
